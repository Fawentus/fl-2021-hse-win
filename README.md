# HW04

## Задание 0

Язык описания конечных автоматов:

Для начала зададим алфавит (в данном случае он будет состоять из слов):
```
alphabet { "северный", "попугай", "синий", "нутрия", "олень" }
```
  
Затем нужно перечислить состояния, которые есть у автомата:
```
states { q0, q1, q2, q3, q4, q5 }
```
  
Нужно указать терминальные вершины:
```
terminal { q1, q5 }
```
  
Иногда состояний может быть слишком много, настолько, что название не способно отразить суть. Будут полезны описания состояний, при необходимости их можно добавить так:
```c++
state q1 { "два синих попугая и один северный олень" } // state <name_state> { <description> }
```
  
Затем нужно добавить переходы между состояниями, они характеризуются состоянием, из которого переходим, в которое переходим, и элементами из алфавита:
```c++
q0 ---> q5 ["северный", "олень"] // <out_state> ---> <in_state> [<elements_of_alphabet>]
```
  
Если автомат создан неверно (нет состояния, которое могло бы быть начальным, или их наобот несколько, не по всем элементам алфавита можно выйти из вершины и тд), то будет выведено сообщение об ошибке. Если всё верно, то начальная вершина будет определена автоматически (это вершина, в которую не входит ни одно ребро, или все входящие ребра - петли).

Если символом алфавита является произвольная последовательность символьного типа `char`, то нужно выделить её в кавычки - `""`. Чтобы использовать `"` в качестве одного из символов последовательности, нужно их экранировать - `\"`, аналогично для использования `\`, нужно экранировать - `\\`. Если символом алфавита является число, то его можно в кавычки не выделять (если выделить, то это будет восприниматься как последовательность символов).

Также можно писать комментарии, как это показано выше.

Пример описания автомата:

Путешественникам, чтобы добраться до волшебного места, нужно обязательно два раза подряд пойти направо, остальные их передвижения не так важны.

```
alphabet { "←", "→", "↑", "↓" }
states { q0, q1, q2}
terminal { q2 }
state q1 { "одна → подряд" }
state q2 { "две → подряд, победа!" }
q0 ---> q1 [ "→" ]
q0 ---> q0 [ "←", "↑", "↓" ]
q1 ---> q2 [ "→" ]
q1 ---> q0 [ "←", "↑", "↓" ]
q2 ---> q2 [ "←", "→", "↑", "↓" ]
```

Этот же пример я буду использовать для описания на языках в первом задании.

## Задание 1

### Полушин Артём

Пример описания автомата на этом языке:

```
"←"
"→"
"↑"
"↓"
Q0 : 1 -> Q1; 0 -> Q0; 2 -> Q0; 3 -> Q0;
Q1 : 1 -> T1; 0 -> Q0; 2 -> Q0; 3 -> Q0;
T1 : 0 -> T1; 1 -> T1; 2 -> T1; 3 -> T1;
```

* **Насколько язык хорошо описан:** буду ориентироваться на описание языка из второго домашнего задания, так как оно сильно изменилось по сравнению с языком из первого. По тестам и регулярному выражению в лексере я поняла, что в начале кода каждый символ должен быть с новой строки. Думаю, это не будет лишним отразить в описании, так как это влияет на использование `"` в качестве части символа алфавита. Еще немного непонятно, как быть, если хочется переходить в другое состояние не по одному символу. В первой домашней работе это выглядело так: `Q₁: в Q₃ по 0-9`, во второй нет ничего про это, в том числе в лексере `-` отдельно не обрабатывается. А если нужен не диапазон символов, а, к примеру, `1, 5, 8`? В лексере есть обработка запятой: `t_SEP = r','`. Могу предположить, что с помощью неё можно перечислить необходимые символы для перехода по ребрам, но это лишь догадка. Ни в описании, ни в примерах нет пояснений, для чего она. Но в остальном очень понятное и доступное описание.
  
* **Насколько язык сам по себе удобен:** немного грустно, что нужно самому считать порядковый номер символа и что (как я поняла) для каждого символа нужно отдельно прописывать переход в другое состояние, даже если они ведут в одно и то же. Но зато по полученному коду можно представить, как выглядит автомат, не так сложно искать ошибки. Довольно удобный язык описания.

* **Если есть поддержка в среде разработки, то насколько она удобная:** была сделана подсветка не для этого языка.

* **Насколько понятные сообщения об ошибках выдает синтаксический анализатор:** анализатор сообщает об ошибке, если втретилось что-то, не соответсявующее спецсимволам или последовательности символов, взятых в кавычки. Язык сам по себе довольно простой и наглядный, в совокупности с указанием места несоответствия, ошибки достаточно понятны.

* **Постараться найти ошибки: неточности описания, несоответствие работы синтаксического анализатора описанию языка, неправильные результаты:** 
  1) некоторые неточности описания приведены в первом пункте
  2) тесты, где анализатор выдавал бы неправильные результаты я не нашла. Но есть тесты, на которых анализатор выдает то, что не отражено в описании (это некоторые тесты, где присутствует запятая, причем ее можно поставить в самых неожиданных местах, это не будет вызывать ошибок): [входные данные](https://github.com/Fawentus/fl-2021-hse-win/blob/HW04/Polushin_ex) - [выходные данные](https://github.com/Fawentus/fl-2021-hse-win/blob/HW04/Polushin_ex.out)

### Сапожников Аркадий

Пример описания автомата на этом языке (это описание лишь алфавита, дальше я совсем запуталась):

```
DE111000101000011010010000111000101000011010010010111000101000011010010001111000101000011010010011ED
```

Пример автора:

```
DE0011000000110001ECBBA0B00110001BACCA0B00110001BAB00110001BA0B00110001BACCA0B00110001BAB00110000BA0B00110010BACCA0B00110010BAB00110000BA0B00110011BACCA0B00110011BAB00110000BA1B00110100BACCA1B00110100BAB00110001BA0B00110001BACCA0B00110011BAB00110001BA0B00110001BACCA0B00110010BAB00110001BA0B00110001BACD
```

* **Насколько язык хорошо описан:** описание довольно подробное, но очень легко запутаться и несовсем понятны некоторые моменты:
  
  1) `"отсортированный список ребер"` - По какому принципу нужно сортировать ребра?
  
  2) `"каждый автомат описывается единственным образом"` - Допустим порядок в описании блоков вершин, алфавита, ребер и порядок самих ребер задается однозначно. Но у пользователя все равно остается возможность менять, к примеру, порядок описания вершин. Они тоже должны быть по какому-то принципу отсортированы? Или автомы, которые отличаются порядком описания вершин считаются одинаковыми? Но в таком случае зачем сортировать ребра?
  
  3) `"нужно научиться записывать слова: "алфавит", "вершинa", "ребро" и "автомат""`, `"для начала оборачивать слово в буквы A (то есть для каджого слова будет верно, что он начинается и заканчивается на букву A)"` и `"Слово алфавит: имя, обернутое в буквы E"`,  - Насколько я понимаю "алфавит" - это "слово", а значит его помимо `E` нужно обернуть (автор подразумевает под этим приписывание в начало и конец спецсимвол) еще и в `A` (только непонятно, в каком порядке должны идти `E` и `A`). В примере есть часть кода: `E011000010110001001100011E`, здесь ничего в `A` не обёрнуто. Значит, "алфавит" это все-таки не "слово"?
  
  4) `"Для слова ребро будем оборачивать его в C"` - Тут то же самое, "ребро" - это "слово". Что вообще такое "слово"? А еще есть "слова": "вершинa" и "автомат", которые тоже обёрнуты, но уже в другие буквы. Больше всего непонятно, что нужно оборачивать в буквы `A` и для чего они нужны. Я совсем запуталась(
  
  5) `"Параметра у вершины: является ли она терминальной и ее описание"`, `"затем описание ребра, обернутое в B"` - Что имеется ввиду под "описанием"? Терминальность вершины, откуда и куда ведет ребро прописывается отдельно. Зачем нужно "описание"?
  
* **Насколько язык сам по себе удобен:** с точки зрения пользователя, если честно, использовать этот язык больно. Как я понимаю, нужно все символы алфавита и названия вершин перевести в код `ASCII` (дана ссылка на [сайт](https://www.rapidtables.com/convert/number/ascii-to-binary.html), где можно это сделать). Затем к этому коду нужно приписать в начало и конец спецсимволы, расположить всё это в верном порядке, отсортировать ребра. Но скорей отталкивает, что по полученному коду чисто визуально сложно понять, какой автомат описан, и также почти нереально искать в этом коде ошибки. Но я посмотрела, как работает лексер. Если использовать его, то разбираться в уже написанном коде более приятно.

* **Если есть поддержка в среде разработки, то насколько она удобная:** в первой домашней работе была приведена подсветка Python.

* **Насколько понятные сообщения об ошибках выдает синтаксический анализатор:** насколько я понимаю, синтаксический анализатор говорит, что что-то не в порядке, если некоторая часть кода не начинается и не заканчивается со спецсимволов. Так можно понять, где забыл что-то дописать.

* **Постараться найти ошибки: неточности описания, несоответствие работы синтаксического анализатора описанию языка, неправильные результаты:** 
  1) некоторые неточности описания приведены в первом пункте
  2) при составлении примера, который был в самом начале, столкнулась с тем, что не все символы можно закодировать одним char-ом. Это не совпадает со словами: `"переведенное в бинарную строку длины 8, так как char - это один байт"`. Кажется, верной обработки кода в таком случае нет. В моем [примере](https://github.com/Fawentus/fl-2021-hse-win/blob/HW04/Sapozhnikov_ex) выводится [что-то странное](https://github.com/Fawentus/fl-2021-hse-win/blob/HW04/Sapozhnikov_ex.out).

## Задание 2

Синтаксический анализатор реализован [здесь]()

Тесты:

1) [входные данные]() - [выходные данные]()
2) [входные данные]() - [выходные данные]()
3) [входные данные]() - [выходные данные]()

## Задание 3

Тесты:

1) Полный детерминированный автомат, у которого есть начальное состояние, и все состояния уникальны: [входные данные]() - [выходные данные]()
2) Автомат, не имеющий начального состояния: [входные данные]() - [выходные данные]()
3) Автомат, символы которого не уникальны: [входные данные]() - [выходные данные]()
4) Неполный автомат: [входные данные]() - [выходные данные]()
5) Недетерминированный автомат: [входные данные]() - [выходные данные]()
6) Автомат без терминальных состояний: [входные данные]() - [выходные данные]()
