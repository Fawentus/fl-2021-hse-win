# HW02

### Задание 1

Построим конечные автоматы и попробуем их упростить:
![](https://raw.githubusercontent.com/Fawentus/fl-2021-hse-win/HW02/a.jpg)
![](https://raw.githubusercontent.com/Fawentus/fl-2021-hse-win/HW02/b.jpg)
Как видно на картинках, если упростить, получим одинаковые конечные автоматы (они выделены красным), значит данные регулярные выражения равны.

### Задание 2

Язык описания конечных автоматов из прошлого домашнего задания:

> Для начала зададим алфавит (в данном случае он будет состоять из слов):
> ```
> alphabet { "северный", "попугай", "синий", "нутрия", "олень" }
> ```
>  
> Затем нужно перечислить состояния, которые есть у автомата:
> ```
> states { q0, q1, q2, q3, q4, q5 }
> ```
>  
> Нужно указать терминальные вершины:
> ```
> terminal { q1, q5 }
> ```
>  
> Иногда состояний может быть слишком много, настолько, что название не способно отразить суть. Будут полезны описания состояний, при необходимости их можно добавить так:
> ```c++
> state q1 { "два синих попугая и один северный олень" } // state <name_state> { <description> }
> ```
>  
> Затем нужно добавить переходы между состояниями, они характеризуются состоянием, из которого переходим, в которое переходим, и элементами из алфавита:
> ```c++
> q0 ---> q5 ["северный", "олень"] // <out_state> ---> <in_state> [<elements_of_alphabet>]
> ```
>  
> Если автомат создан неверно (нет состояния, которое могло бы быть начальным, или их наобот несколько, не по всем элементам алфавита можно выйти из вершины и тд), то такой автомат создан не будет. Если всё верно, то начальная вершина будет определена автоматически (это вершина, в которую не входит ни одно ребро, или все входящие ребра - петли)

В нем уже есть возможность сделать символами алфавита произвольные последовательности символьного типа `char`, так как они выделены в кавычки - `""` (чтобы использовать `"` в качестве одного из символов последовательности, нужно их экранировать - `\"`, аналогично для использования `\`, нужно экранировать - `\\`).

### Задание 3

[Лексер](https://github.com/Fawentus/fl-2021-hse-win/blob/HW02/myLex.py) написан на языке Python, использован ply.lex. Консольное приложение запускается командой: 
```
python3.8 myLex.py "<name_file>"
```

Например, так запускается [мой "нулевой" тест](https://github.com/Fawentus/fl-2021-hse-win/blob/HW02/ex):
```
python3.8 myLex.py "ex"
```
Этот код не строит осмысленный автомат, я включила туда то, что могло бы продемонстрировать все возможности моего лексера. [Это](https://github.com/Fawentus/fl-2021-hse-win/blob/HW02/ex.out) то, что будет в выходном файле после работы программы (значения токенов типа `STR` выводятся с отбрасыванием `""`).
  
Это примеры работы лексера на тестах из прошлого домашнего задания:
  
  [Тест 1](https://github.com/Fawentus/fl-2021-hse-win/blob/HW02/ex1) - [результат работы лексера](https://github.com/Fawentus/fl-2021-hse-win/blob/HW02/ex1.out)
  
  [Тест 2](https://github.com/Fawentus/fl-2021-hse-win/blob/HW02/ex2) - [результат работы лексера](https://github.com/Fawentus/fl-2021-hse-win/blob/HW02/ex2.out)
  
  [Тест 3](https://github.com/Fawentus/fl-2021-hse-win/blob/HW02/ex3) - [результат работы лексера](https://github.com/Fawentus/fl-2021-hse-win/blob/HW02/ex3.out)
