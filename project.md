# Как парсится c++ (на примере GCC)

В машинный код приложения на c и c++ переводятся один раз - перед запуском программы.
Этот процесс и называется компиляцией. Компилятор переводит исходный код, написанный на одном из языков программирования,
и преобразует его в семантически эквивалентный объектный код.

## Процесс компиляции

Такое преобразование происходит постепенно:

![](https://intuit.ru/EDI/08_01_19_2/1546899581-11707/tutorial/439/objects/3/files/03_01sm.gif)

Лексический анализ - анализ исходной программы, при котором поток символов исходной программы считывается слева направо и группируется в токены, 
представляющие собой совокупность последовательностей символов с определенным значением.

Синтаксический анализ - анализ, при котором символы или токены иерархически группируются во вложенные конструкции. Токены 
исходной программы группируются в грамматически фразы, представленные обычно в виде дерева.

Семантический анализ - анализ наличия семантических ошибок в исходной программе и накапливается информация о типах. 
При таком анализе используются иерархические структуры, полученные во время синтаксического анализа для идентификации 
операторов и операндов выражений и инструкций. На этом этапе также происходит проверка типов.

Но на деле всё немного сложнее. К примеру, оптимизация может выполняться не один раз в конце, а на разных этапах.
Можно процесс компиляции разделить на три основных этапа, которые будут включать в себя приведенные выше фазы:

1) Front End
2) Middle End
3) Back End

Поговорим о них подробнее.

### Front End

На этом этапе из кода удаляются все незначащие символы (в случае c++ это, к примеру, лишние пробелы), 
комментарии и другое форматирование. Также добавляются в код хэдеры (#include), заменяются макросы (#define)
их значениями, выбирают нужные куски кода в соответствии с условиями #if, #ifdef и #ifndef.
Хэдеры, включенные в программу с помощью директивы #include, добавляются рекурсивно. Именно поэтому, нужно использовать:

```c++
#ifndef NAME
#define NAME

#endif
```
или директиву, не включенную в стандарт, но широко распространенную:

```c++
#pragma once
```
Это называют предпроцессингом.

Затем производится проверка синтаксической структуры программы, диагностика на соответствие языку, 
создание внутренних структур для типов данных и переменных,
объявленных в программе (таблица символов). Такжа происходит отладка информации, такой как имена 
файлов и номера строк. Это может пригодиться, к примеру для вывода сообщений об ошибках.

Исходная программа преобразуется в более лаконичную форму, называемую intermediate representation - IR.
Для этого создается структура данных - Abstract Syntax Trees (AST), которая представляет каждый оператор 
в некоторой заданной иерархии.

Например для `x = y - z * 3` AST выглядит так: 

![](https://web.archive.org/web/20070715155911im_/http://www.redhat.com/magazine/002dec04/features/gcc/figs/ast.png)

Более сложный пример:

``` c++
while (b != 0) {
    if (a > b) {
        a = a − b;
    } else {
        b = b − a;
    }
}
return a;
```

Для него AST будет выглядеть так:

![](https://upload.wikimedia.org/wikipedia/commons/c/c7/Abstract_syntax_tree_for_Euclidean_algorithm.svg)

### Middle End

На этом этапе есть две основные цели: оптимизация по времени работы и оптимизация по занимаемой памяти.
Какие оптимизации есть:

1) Упрощения выражений: для этого используются ассоциативность, коммутативность, дистрибутивность
и другие свойства операторов. Например, `i + 1 - i` преобразуется в `1`.
2) Вычисление констант: например, `a = 4 + 3 - 8` можно заменить на `a = -1`.
3) Устранение избыточности: существует несколько методов, наиболее распространенные из них:
    * Вычисления внутри циклов, которые дают один и тот же результат для каждой итерации, 
 выводятся за пределы цикла. Например в этом случае:
 
 ```
 k = 10;
 b = 6;
 while (k > 0) {
     a = b + 3;
     k -= a;
 }
 return k;
 ```
 
 `a = b + 3;` можно вынести за пределы цикла. В результате получим:
 
 ```
 k = 10;
 b = 6;
 a = b + 3;
 while (k > 0) {
     k -= a;
 }
 return k;
 ```
 
 Но эта оптимизация работает только с простыми случаями, даже самый крутой компилятор не всегда может
 обработать что-то более сложное. Например, оптимизатор не смог помочь создателям игры GTA Online,
 которые (по мнению T0ST) использовали в цикле функцию `sscanf`, в свою очередь вызывающую `strlen` для неизменяемого
 файла. В том числе и из-за этого время загрузки игры было достаточно большим (ссылка на статью [](https://nee.lv/2021/02/28/How-I-cut-GTA-Online-loading-times-by-70/)).
 
    * Если выражение вычисляется более одного раза и его операнды 
 никогда не изменяются, повторные вычисления заменяются результатом, вычисленным в первом.
    * Частичное устранение избыточности. Оно применяет предыдущие методы не для выражения целиком,
 а для некоторой его части.
 
 ### Back End
 
 На заключительном этапе перевода создается машинный код для целевой архитектуры. На этом этапе
 компилятор должен обладать очень подробными знаниями об оборудовании, на котором будет
 выполняться программа. Промежуточное представление программы
 преобразуется в форму, напоминающую машинный язык. В этой форме можно применять преобразования, 
 использующие преимущества целевой архитектуры. Например:

1) Распределение регистров. Максимизируется количество переменных, которые назначаются регистрам,
которые работают более быстро.
2) Планирование кода. Используют преимущества современных процессоров для перестановки инструкций
таким образом, чтобы несколько инструкций находились на разных стадиях выполнения одновременно.
Из-за этой оптимизации код может выполняться не так, как он задумывался. К примеру, при использовании
потоков нам может быть важен конкретный порядок выполнения действий. При этой оптимизации он мог
измениться. В том числе и для того, чтобы избежать неожиданного поведения программы в этом случае,
нужно использовать `mutex`.

Даже после окончательной генерации кода полученный код, как правило, не готов к запуску.
Некоторые компиляторы, в том числе и GCC, генерируют ассемблерный код, который затем подается 
в ассемблер для генерации объектного кода. Это называют ассемблирование.
После создания объектного кода происходит компоновка - сбор всех объектных файлов
и библиотек, необходимых для создания окончательного исполняемого файла.
В конце выполняется загрузка. При этом происходит загрузка программы в память. На данной 
стадии также возможна подгрузка динамических библиотек (в Windows они имеют расширение `.dll` 
(сокращение от dynamic link library), в Linux `.so` (сокращение от shared object)). Динамические библиотеки не являются частью
исполняемого файла. Разные программы могут совместно использовать одну копию динамической библиотеки, 
что значительно экономит используемое пространство. А еще её можно обновлять без необходимости 
перекомпиляции всех исполняемых файлов, которые её используют.

## Внутренняя организация GCC

GCC разработан вокруг двух разных IR:
1) Trees, что по сути является AST
2) Register Transfer Language (RTL). Оно используется GCC для оптимизации и генерации кода. 

TODO Обзор процесса компиляции в GCC:

![](https://web.archive.org/web/20070715155927im_/http://www.redhat.com/magazine/002dec04/features/gcc/figs/tree-ssa-phases.png)

### GENERIC

Хотя некоторые интерфейсы используют одно и то же древовидное представление, не существует 
единого представления, используемого всеми интерфейсами GCC. Каждый интерфейс отвечает за 
перевод своих собственных деревьев синтаксического анализа непосредственно в RTL. Чтобы решить
эту проблему, мы ввели новое представление, названное GENERIC, которое является просто 
надмножеством всех существующих древовидных представлений в GCC. Вместо создания RTL каждый
интерфейс отвечает за преобразование своих собственных деревьев синтаксического анализа в 
GENERIC деревья. Поскольку GENERIC деревья не зависят от языка, вся семантика входного языка 
должно быть явно описано каждым интерфейсом. Некоторые из этих семантик переводятся в проходе
"обобщение", в то время как другие переводятся в проходе "упрощение".

### GIMPLE

Преобразование в GENERIC удаляет языковые зависимости из представления программы. Тем не менее, 
общие деревья по-прежнему являются структурно сложными, поэтому следующий шаг-разбить их на
более управляемые части. Это новое представление, называемое GIMPLE, лексически идентично
GENERIC, но оно накладывает структурные ограничения на операторы. Например:

1) Ни одно выражение не может содержать более 3 операндов 
2) аргументы для вызова функции могут быть только переменными (вызовы функций не могут быть 
вложенными)
3) предикат if оператор может содержать только одно сравнение

### Различия между GENERIC и GIMPLE

``` c++
// GENERIC

if (foo (a + b, c)) {
    c = b++ / a;
}
return c;
```

``` c++
// GIMPLE

t1 = a + b;
t2 = foo (t1, c);
if (t2 != 0) {
    t3 = b;
		b = b + 1;
		c = t3 / a;
}
return c;
```

### Tree SSA

которое представляет собой представление, используемое компилятором внутри для отслеживания 
того, как данные проходят через программу. Эта информация необходима компилятору для принятия
решений по оптимизации. Учитывая, что фреймворк был реализован поверх древовидной структуры
данных и использует SSA для анализа потоков данных, мы назвали его Дерево SSA.

Хотя деревья синтаксического анализа GCC предоставляют очень подробную информацию об исходной
программе, они не подходят для оптимизации по двум основным причинам:

1) Отсутствие общего представительства
Не существует единого древовидного представления, общего для всех интерфейсов. Обратите
внимание на рис. 2, “Существующий процесс компиляции в GCC”, как каждый интерфейс генерирует
свой собственный набор деревьев. Оптимизатор дерева должен быть реализован один раз для 
каждого интерфейса, поддерживаемого GCC. Это было бы кошмаром для обслуживания и создало 
бы значительную нагрузку на каждый новый интерфейс.
2) Структурная сложность
Деревья синтаксического анализа, сгенерированные Front End, являются почти 
точным представлением исходной входной программы. Таким образом, выражения могут быть объединены 
почти бесконечным количеством способов. Эта гибкость очень удобна для людей из-за своей
выразительной силы. Однако компиляторы, будучи простодушными автоматами, которыми они 
являются, не могут легко справиться с ними. Чтобы преодолеть эти ограничения, мы ввели два новых
промежуточных представления на основе дерева, называемых GENERIC и GIMPLE. GENERIC устраняет 
отсутствие общего древовидного представления между различными интерфейсами. GIMPLE 
решает сложные задачи, которые облегчают обнаружение данных и управление потоком в программе.

это представление, которое находится поверх GIMPLE и очень явно отображает поток данных в программе.
Центральная идея заключается в управлении версиями. Форма SSA требует, чтобы каждая переменная 
назначалась только один раз. Поэтому каждый раз, когда переменной X присваивается 
новое значение, компилятор создает новую версию X, и в следующий раз, когда эта переменная X
используется, компилятор ищет последнюю версию X и использует ее. Обратите внимание, что это 
представление полностью внутреннее для компилятора, оно не отображается в сгенерированном коде
и не может быть замечено отладчиком.

К примеру:

``` c++
// GIMPLE

a = 3;
b = 9;
c = a + b;
a = b + 1;
d = a + c;
return d;
```

``` c++
// SAA

a_1 = 3;
b_2 = 9;
c_3 = a_1 + b_2;
a_4 = b_2 + 1;
d_5 = a_4 + c_3;
return d_5;
```

Обратите внимание, что каждое назначение создает новый номер версии для изменяемой переменной. 
И каждый раз, когда переменная используется в выражении, она всегда использует последнюю версию.

Почему это полезно? Рассмотрим оптимизацию вычисление констант, о которой уже говорили.
Поскольку программа находится в форме SSA, и все переменные имеют номера версий, компилятор может
просто создавать массивы, индексированные по номеру версии, чтобы отслеживать постоянные значения.
Предположим, у нас был массив CST для этой цели. В этом случае CST[1] = 3 и CST[2] = 9. Таким 
образом, когда компилятор проверяет инструкцию в строке c_3 = a_1 + b_2, он может 
сделать вывод , что c_3 должно быть всегда 12 (CST[3] = 12). После просмотра всех заявлений 
таким образом, мы в конечном итоге получаем:

``` c++
// SAA

a_1 = 3;
b_2 = 9;
c_3 = 12;
a_4 = 30;
d_5 = 42;
return 42;
```

И теперь, после распространения всех констант, мы обнаруживаем, что ни одно из утверждений вообще 
не является действительно полезным. Эта программа просто вычисляет и возвращает значение 42.

Теперь, что происходит, когда невозможно определить, какова последняя версия переменной? 
Реальные программы редко представляют собой прямой код, существуют циклы и условные обозначения,
которые изменяют поток управления. Например, в следующей программе компилятору может быть
невозможно определить, какая ветвь условного условия будет взята во время выполнения:

``` c++
x = foo();
if (x > 10) {
    a = 92;
}
else {
    a = 23;
}
return a;
```

Когда компилятор пытается преобразовать приведенную выше программу в форму SSA, он не знает, 
какая из двух версий для переменной a для использования. Чтобы устранить эту неоднозначность, 
компилятор создает третью версию для переменной a это слияние двух конфликтующих версий. 
Эта операция слияния известна как функция PHI:

``` c++
x_1 = foo();
if (x_1 > 10) {
    a_2 = 92;
}
else {
    a_3 = 23;
}
a_4 = PHI(a_2, a_3);
return a_4;
```

### RTL

Каждый интерфейс языка генерирует свою собственную версию 
деревьев. Анализатор C генерирует деревья C, анализатор C++ генерирует деревья C++ и так далее.
Каждый версия отличается по-своему, поэтому для анализа и оптимизации деревьев потребуется N 
различных реализаций, по одной для каждого интерфейса. Это вряд ли масштабируемо, поэтому вся 
работа по оптимизации выполняется в RTL.

RTL можно рассматривать как язык ассемблера для машины с бесконечным числом регистров. Будучи
низкоуровневым представлением, RTL хорошо работает для оптимизаций, которые близки к цели 
(например, распределение регистров, оптимизация слотов задержки, глазки и т. Д.). Кроме того,
GCC предлагает довольно гибкий способ для разработчиков описать свою целевую машину при переносе
GCC на новую архитектуру. На самом деле, когда он был первоначально реализован, GCC почти сразу
же создавал RTL, поэтому вполне естественно, что большая часть компилятора реализована вокруг него.

Однако для некоторых анализов и преобразований требуется информация более высокого уровня о 
программе, которую невозможно (или очень сложно) получить из RTL (например, ссылки на массивы,
типы данных, ссылки на переменные программы, структуры потоков управления). В общем, в RTL
представлено слишком много целевых функций. Например, если целевой объект не может обрабатывать 
более 32-разрядных величин в регистре, представление RTL разбивает значения, превышающие 32 бита,
на несколько значений. Кроме того, такие вещи, как соглашения о вызове функций, раскрываются 
в подробно в RTL, поэтому один вызов функции может охватывать несколько инструкций RTL. Все
эти детали затрудняют реализацию анализа и оптимизации, которым на самом деле не нужно
беспокоиться о деталях цели. Со временем некоторые из этих преобразований были реализованы
в RTL, но конечным результатом является код, который чрезмерно запутан, сложен в обслуживании 
и подвержен ошибкам.

# Особенности синтаксиса с++ (в том числе и lexer hack)

# Сколько gcc тратит времени на разные этапы (говорят, что gcc проводит чуть ли не 40% времени за синтаксическим анализом)

# Может ли парсер выдать отвратительную производительность? (пример)

# Источники
1) [Статья Diego Novillo](https://web.archive.org/web/20090401215553/http://www.redhat.com/magazine/002dec04/features/gcc/), 
одного из главных архитекторов Tree SSA, платформы оптимизации для GCC.
2) [Вопрос про значения merge, phi, effectphi and dead](https://stackoverflow.com/questions/57463700/meaning-of-merge-phi-effectphi-and-dead-in-v8-terminology)
на stackoverflow
3) [Статья про использование PHI в SSA](https://mapping-high-level-constructs-to-llvm-ir.readthedocs.io/en/latest/control-structures/ssa-phi.html)
4) [Страница в wikipedia об SSA](https://en.wikipedia.org/wiki/Static_single_assignment_form)
5) [Страница в wikipedia об IR](https://en.wikipedia.org/wiki/Intermediate_representation)
6) ["A Simple Graph-Based Intermediate Representation" by Cliff Click and Michael Paleczny](https://www.oracle.com/technetwork/java/javase/tech/c2-ir95-150110.pdf) - 
здесь можно найти более содержательные примеры AST
7) [Страница в wikipedia об AST](https://en.wikipedia.org/wiki/Abstract_syntax_tree#:~:text=In%20computer%20science%2C%20an%20abstract,the%20structural%20or%20content-related%20details)
8) [](https://habr.com/ru/post/478124/)

